/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is not neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@wecco/core/dist/wecco-core.es5.js":
/*!*********************************************************!*\
  !*** ./node_modules/@wecco/core/dist/wecco-core.es5.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"WeccoElement\": () => /* binding */ WeccoElement,\n/* harmony export */   \"app\": () => /* binding */ app,\n/* harmony export */   \"component\": () => /* binding */ component,\n/* harmony export */   \"define\": () => /* binding */ define,\n/* harmony export */   \"html\": () => /* binding */ html,\n/* harmony export */   \"removeAllChildren\": () => /* binding */ removeAllChildren,\n/* harmony export */   \"resolve\": () => /* binding */ resolve,\n/* harmony export */   \"shadow\": () => /* binding */ shadow,\n/* harmony export */   \"updateElement\": () => /* binding */ updateElement\n/* harmony export */ });\n/*\r\n * This file is part of wecco.\r\n *\r\n * Copyright (c) 2019 - 2020 The wecco authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nfunction updateElement(element, request) {\r\n    if (typeof (request) === \"string\") {\r\n        element.innerHTML = request;\r\n    }\r\n    else if (request instanceof Element) {\r\n        element.appendChild(request);\r\n    }\r\n    else if (isElementUpdater(request)) {\r\n        request.updateElement(element);\r\n    }\r\n    else {\r\n        request(element);\r\n    }\r\n}\r\nfunction isElementUpdater(request) {\r\n    return \"updateElement\" in request;\r\n}\r\n/**\r\n * Resolves the Element described by the given selector.\r\n * @param selector the selector\r\n * @param parent an optional parent to start resolving from. Defaults to `document.body`\r\n */\r\nfunction resolve(selector, parent) {\r\n    if (typeof selector !== \"string\") {\r\n        return selector;\r\n    }\r\n    if (!parent) {\r\n        parent = document.body;\r\n    }\r\n    return parent.querySelector(selector);\r\n}\r\n/**\r\n * Removes all child nodes from the given node.\r\n * @param node the node to remove children from\r\n */\r\nfunction removeAllChildren(node) {\r\n    while (node.firstChild) {\r\n        node.removeChild(node.firstChild);\r\n    }\r\n}\n\n/*\r\n * This file is part of wecco.\r\n *\r\n * Copyright (c) 2019 - 2020 The wecco authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * `WeccoElement` defines the base class for all custom elements created by wecco.\r\n * Subclasses of this class are generated for each element which gets `define`d. They conform to the custom web components protocol.\r\n */\r\nclass WeccoElement extends HTMLElement {\r\n    constructor() {\r\n        super(...arguments);\r\n        /** The bound data */\r\n        this.data = {};\r\n        /** Flag that marks whether this component is connected to the DOM or not. */\r\n        this.connected = false;\r\n        /** The render context instance to use */\r\n        this.renderContext = new WeccoElementRenderContext(this);\r\n        /** Flag that marks whether an update has been requested */\r\n        this.updateRequested = false;\r\n        /**\r\n         * A set of ids of callbacks provided to `RenderContext.once` that have been executed.\r\n         */\r\n        this.executedOnceCallbackIds = new Set();\r\n        /**\r\n         * Callback to invoke in order to trigger an update of this element\r\n         * @returns this to enable invocation chaining\r\n         */\r\n        this.requestUpdate = () => {\r\n            if (this.updateRequested) {\r\n                return;\r\n            }\r\n            this.updateRequested = true;\r\n            setTimeout(this.executeUpdate.bind(this), 1);\r\n            return this;\r\n        };\r\n        this.emit = (eventName, payload) => {\r\n            const event = new CustomEvent(eventName, {\r\n                detail: payload,\r\n                bubbles: true,\r\n                cancelable: true,\r\n                composed: true,\r\n            });\r\n            this.dispatchEvent(event);\r\n            return this;\r\n        };\r\n    }\r\n    /**\r\n     * Partially updates the bound data with the data given in `data`.\r\n     * @param data the partial data to update\r\n     * @returns this to enable invocation chaining\r\n     */\r\n    setData(data) {\r\n        if (data) {\r\n            Object.keys(data).forEach(k => this.data[k] = data[k]);\r\n        }\r\n        if (this.connected) {\r\n            this.requestUpdate();\r\n        }\r\n        return this;\r\n    }\r\n    /**\r\n     * Mounts this element to the DOM node passed to this method.\r\n     * @param elementOrSelector either the element or an selector, which gets resolved using `document.querySelector`\r\n     * @returns this to enable invocation chaining\r\n     */\r\n    mount(elementOrSelector) {\r\n        resolve(elementOrSelector).appendChild(this);\r\n        return this;\r\n    }\r\n    /**\r\n     * (Life cycle method)[https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_custom_elements#Using_the_lifecycle_callbacks] for the custom element.\r\n     */\r\n    connectedCallback() {\r\n        Array.prototype.forEach.call(this.attributes, (attr) => {\r\n            if (this.observedAttributes.indexOf(attr.name) !== -1) {\r\n                this.data[attr.name] = attr.value;\r\n            }\r\n        });\r\n        this.connected = true;\r\n        this.updateDom();\r\n    }\r\n    /**\r\n     * (Life cycle method)[https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_custom_elements#Using_the_lifecycle_callbacks] for the custom element.\r\n     */\r\n    disconnectedCallback() {\r\n        this.childNodes.forEach(this.removeChild.bind(this));\r\n        this.connected = false;\r\n    }\r\n    /**\r\n     * (Life cycle method)[https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_custom_elements#Using_the_lifecycle_callbacks] for the custom element.\r\n     */\r\n    attributeChangedCallback(name, oldValue, newValue) {\r\n        const object = {};\r\n        object[modelKeyForAttributeName(name)] = newValue;\r\n        this.setData(object);\r\n    }\r\n    registerOnceCallback(id, callback) {\r\n        if (this.executedOnceCallbackIds.has(id)) {\r\n            return;\r\n        }\r\n        this.executedOnceCallbackIds.add(id);\r\n        Promise.resolve()\r\n            .then(() => {\r\n            callback();\r\n        });\r\n    }\r\n    /**\r\n     * `executeUpdate` performs an update in case the dirty flag has been set.\r\n     */\r\n    executeUpdate() {\r\n        if (!this.updateRequested) {\r\n            return;\r\n        }\r\n        Promise.resolve()\r\n            .then(() => {\r\n            const observed = this.observedAttributes;\r\n            Object.keys(this.data).forEach(k => {\r\n                if (observed.indexOf(k) > -1) {\r\n                    this.setAttribute(attributeNameForModelKey(k), this.data[k]);\r\n                }\r\n            });\r\n            this.updateDom(true);\r\n        });\r\n    }\r\n    updateDom(removePreviousDom = false) {\r\n        if (removePreviousDom) {\r\n            let host;\r\n            if (this.shadowRoot) {\r\n                host = this.shadowRoot;\r\n            }\r\n            else {\r\n                host = this;\r\n            }\r\n            removeAllChildren(host);\r\n        }\r\n        const elementUpdate = this.renderCallback(this.data || {}, this.renderContext);\r\n        this.updateRequested = false;\r\n        updateElement(this, elementUpdate);\r\n    }\r\n}\r\n/**\r\n * Implementation of `RenderContext` for a `WeccoElement`\r\n */\r\nclass WeccoElementRenderContext {\r\n    constructor(component) {\r\n        this.component = component;\r\n    }\r\n    requestUpdate() {\r\n        this.component.requestUpdate();\r\n        return this;\r\n    }\r\n    emit(event, payload) {\r\n        this.component.emit(event, payload);\r\n        return this;\r\n    }\r\n    addEventListener(event, listener) {\r\n        this.component.addEventListener(event, listener);\r\n        return this;\r\n    }\r\n    once(id, callback) {\r\n        this.component.registerOnceCallback(id, callback);\r\n        return this;\r\n    }\r\n}\r\n/**\r\n * `define` is used to define a new wecco component which is also a custom element.\r\n * The render callback provided to define will be called whenever the element`s content needs to be updated.\r\n * @param name the name of the custom element. Must follow the custom element specs (i.e. the name must contain a dash)\r\n * @param renderCallback the render callback\r\n * @param observedAttributes list of attribute names to observe for changes and bind to data\r\n * @returns an instance of a `ComponentFactory` which can produce instances of the defined component\r\n */\r\nfunction define(name, renderCallback, ...observedAttributes) {\r\n    const observedAttributesValue = observedAttributes.map(a => Array.isArray(a) ? a : [a]).reduce((a, v) => a.concat(v), []);\r\n    const observedAttributeNames = observedAttributesValue.map(v => attributeNameForModelKey(v));\r\n    window.customElements.define(name, class extends WeccoElement {\r\n        constructor() {\r\n            super(...arguments);\r\n            this.renderCallback = renderCallback;\r\n            this.observedAttributes = observedAttributesValue;\r\n        }\r\n        /**\r\n         * Getter used to retrieve the list of attribute names to watch for changes.\r\n         */\r\n        static get observedAttributes() {\r\n            return observedAttributeNames;\r\n        }\r\n    });\r\n    return component.bind(null, name);\r\n}\r\n/**\r\n * Converts the name of a model attribute to a corresponding HTML attribute name.\r\n * This is basically a conversion from camel case to dash case.\r\n * @param modelKey the model key name\r\n * @returns the corresponding attribute name\r\n */\r\nfunction attributeNameForModelKey(modelKey) {\r\n    let result = \"\";\r\n    let wasUpper = false;\r\n    for (let c of modelKey) {\r\n        if (c.toUpperCase() === c) {\r\n            if (wasUpper) {\r\n                result += \"-\";\r\n            }\r\n            result += c.toLowerCase();\r\n            wasUpper = true;\r\n        }\r\n        else {\r\n            result += c;\r\n            wasUpper = false;\r\n        }\r\n    }\r\n    return result;\r\n}\r\n/**\r\n * Converts the name of a HTML attribute to a corresponding model attribute.\r\n * This is basically a conversion from dash case to camel case.\r\n * @param attributeName the attribute name\r\n * @returns the corresponding model key name\r\n */\r\nfunction modelKeyForAttributeName(attributeName) {\r\n    let result = \"\";\r\n    let wasDash = false;\r\n    for (let c of attributeName) {\r\n        if (c === \"-\") {\r\n            wasDash = true;\r\n        }\r\n        else if (wasDash) {\r\n            result += c.toUpperCase();\r\n            wasDash = false;\r\n        }\r\n        else {\r\n            result += c;\r\n        }\r\n    }\r\n    return result;\r\n}\r\n/**\r\n * Creates an instance of a `define`d element which will use the given `data` and will be added to the given `host` element.\r\n * This is an alternative approach to using the `ComponentFactory` returned by `define` which does not require a handle\r\n * to the component factory but uses the browser's built-in registry for custom web components.\r\n *\r\n * The following two snippets as essentially the same:\r\n *\r\n * ```typescript\r\n * const SomeComponent = define(\"some-component\", (data: SomeComponentData, requestUpdate) => {\r\n *      // ..\r\n * })\r\n *\r\n * SomeComponent({}).mount(\"#body\")\r\n * ```\r\n * vs.\r\n * ```typescript\r\n * define(\"some-component\", (data: SomeComponentData, requestUpdate) => {\r\n *      // ..\r\n * })\r\n *\r\n * component(\"some-component\", SomeComponent({}).mount(\"#body\")\r\n * ```\r\n *\r\n * @param componentName the component name\r\n * @param data the bound data\r\n * @param host the host to add the component to\r\n */\r\nfunction component(componentName, data, host) {\r\n    const el = document.createElement(componentName);\r\n    if (!(el instanceof WeccoElement)) {\r\n        console.error(\"Element is not a defined Weco element:\", el);\r\n        return;\r\n    }\r\n    el.setData(data);\r\n    if (typeof host !== \"undefined\" && host !== null) {\r\n        el.mount(host);\r\n    }\r\n    return el;\r\n}\n\n/*\r\n * This file is part of wecco.\r\n *\r\n * Copyright (c) 2019 - 2020 The wecco authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Used to create a [`ShadowRoot`](https://developer.mozilla.org/en-US/docs/Web/API/ShadowRoot) and add content to it.\r\n * @param content the callback to add content to the shadow root\r\n */\r\nfunction shadow(content) {\r\n    return (host) => {\r\n        const shadow = host.shadowRoot || host.attachShadow({ mode: \"open\" });\r\n        if (typeof content === \"function\") {\r\n            content.call(null, shadow);\r\n        }\r\n        else {\r\n            updateElement(shadow.getRootNode(), content);\r\n        }\r\n    };\r\n}\n\n/*\r\n * This file is part of wecco.\r\n *\r\n * Copyright (c) 2019 - 2020 The wecco authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * `html` is a string tag to be used with string templates. The tag generates\r\n * a `ContentProducer` that can be used as a return from a wecco element's render\r\n * callback.\r\n * @param strings the string parts of the template\r\n * @param args the arguments of the template\r\n */\r\nfunction html(strings, ...args) {\r\n    const key = HtmlTemplateCache.calculateCacheKey(strings);\r\n    if (HtmlTemplateCache.instance.has(key)) {\r\n        return HtmlTemplateCache.instance.get(key).clone(args);\r\n    }\r\n    const result = HtmlTemplate.fromTemplateString(strings, args);\r\n    HtmlTemplateCache.instance.set(key, result);\r\n    return result;\r\n}\r\nclass HtmlTemplateCache {\r\n    constructor() {\r\n        this.entries = new Map();\r\n    }\r\n    static calculateCacheKey(strings) {\r\n        let result = \"\";\r\n        strings.forEach((s, i) => {\r\n            result += s;\r\n            if (i < strings.length - 1) {\r\n                result += `\\${${i}}`;\r\n            }\r\n        });\r\n        return result;\r\n    }\r\n    has(key) {\r\n        return this.entries.has(key);\r\n    }\r\n    get(key) {\r\n        return this.entries.get(key);\r\n    }\r\n    set(key, value) {\r\n        this.entries.set(key, value);\r\n    }\r\n}\r\nHtmlTemplateCache.instance = new HtmlTemplateCache();\r\nconst WeccoHtmlIdDataAttributeName = \"data-wecco-html-id\";\r\nclass CommentNodeBinding {\r\n    constructor(id, index) {\r\n        this.id = id;\r\n        this.index = index;\r\n    }\r\n    applyBinding(root, data) {\r\n        const [insertPoint, comment] = this.findNode(root);\r\n        const d = data[this.index];\r\n        let dataArray;\r\n        if (Array.isArray(d)) {\r\n            dataArray = d;\r\n        }\r\n        else {\r\n            dataArray = [d];\r\n        }\r\n        dataArray.forEach(d => {\r\n            if (d instanceof Element) {\r\n                insertPoint.insertBefore(d, comment);\r\n            }\r\n            else if (d instanceof HtmlTemplate) {\r\n                d.createContentElements().forEach(n => insertPoint.insertBefore(n, comment));\r\n            }\r\n            else {\r\n                insertPoint.insertBefore(document.createTextNode(d), comment);\r\n            }\r\n        });\r\n        insertPoint.removeChild(comment);\r\n    }\r\n    findNode(root) {\r\n        let parentElement;\r\n        if (this.id === null) {\r\n            parentElement = root;\r\n        }\r\n        else {\r\n            parentElement = root.querySelector(`[${WeccoHtmlIdDataAttributeName}=\"${this.id}\"]`);\r\n        }\r\n        if (parentElement) {\r\n            for (let child of Array.from(parentElement.childNodes)) {\r\n                if ((child instanceof Comment) && child.data === `{{wecco-html-${this.index}}}`) {\r\n                    return [parentElement, child];\r\n                }\r\n            }\r\n        }\r\n        console.error(`No such element with ${WeccoHtmlIdDataAttributeName}=${this.id} nested under `, root);\r\n        return [parentElement, null];\r\n    }\r\n}\r\nclass AttributeBinding {\r\n    constructor(attributeName, elementId, dataIndex) {\r\n        this.attributeName = attributeName;\r\n        this.elementId = elementId;\r\n        this.dataIndex = dataIndex;\r\n    }\r\n    applyBinding(root, data) {\r\n        var _a;\r\n        const node = root.querySelector(`[${WeccoHtmlIdDataAttributeName}=\"${this.elementId}\"]`);\r\n        if (!(node instanceof Element)) {\r\n            console.error(`No such element with ${WeccoHtmlIdDataAttributeName}=${this.elementId} nested under `, root);\r\n            return;\r\n        }\r\n        const element = node;\r\n        if (this.attributeName.startsWith(\"@\")) {\r\n            if (element.getAttribute(this.attributeName) !== `{{wecco-html-${this.dataIndex}}}`) {\r\n                console.error(\"Invalid event listener binding:\", element, this.attributeName);\r\n                return;\r\n            }\r\n            element.removeAttribute(this.attributeName);\r\n            const eventName = this.attributeName.substr(1);\r\n            if (eventName === \"mount\") {\r\n                // The \"mount\" event is special to HtmlTemplates. It allows a listener to \r\n                // work on the actual DOM element, once it has been mounted. Thus, we \r\n                // bind the supplied listener to receive the element.\r\n                element.addEventListener(eventName, data[this.dataIndex].bind(null, element));\r\n            }\r\n            else {\r\n                element.addEventListener(eventName, data[this.dataIndex]);\r\n            }\r\n            return;\r\n        }\r\n        if (this.attributeName.startsWith(\"?\")) {\r\n            element.removeAttribute(this.attributeName);\r\n            if (data[this.dataIndex]) {\r\n                const name = this.attributeName.substr(1);\r\n                element.setAttribute(name, name);\r\n            }\r\n            return;\r\n        }\r\n        let valueFromData = (_a = data[this.dataIndex]) !== null && _a !== void 0 ? _a : \"\";\r\n        let value = element.getAttribute(this.attributeName);\r\n        value = value.replace(`{{wecco-html-${this.dataIndex}}}`, valueFromData);\r\n        if (this.attributeName === \"value\" && element instanceof HTMLTextAreaElement) {\r\n            element.innerText = value;\r\n        }\r\n        else {\r\n            element.setAttribute(this.attributeName, value);\r\n        }\r\n    }\r\n}\r\nconst PlaceholderAttributeRegex = /[a-z0-9-_@]+\\s*=\\s*$/i;\r\nconst PlaceholderSingleQuotedAttributeRegex = /[a-z0-9-_@]+\\s*=\\s*'[^']*$/i;\r\nconst PlaceholderDoubleQuotedAttributeRegex = /[a-z0-9-_@]+\\s*=\\s*\"[^\"]*$/i;\r\nclass HtmlTemplate {\r\n    constructor(templateString, data, template) {\r\n        this.bindings = [];\r\n        this.templateString = templateString;\r\n        this.data = data;\r\n        this.template = template;\r\n        this.determineBindings(this.template.content);\r\n    }\r\n    static fromTemplateString(strings, args) {\r\n        const templateString = HtmlTemplate.generateHtml(strings);\r\n        const template = document.createElement(\"template\");\r\n        template.innerHTML = templateString;\r\n        return new HtmlTemplate(templateString, args, template);\r\n    }\r\n    clone(args) {\r\n        return new HtmlTemplate(this.templateString, args, this.template);\r\n    }\r\n    createContentElements() {\r\n        const content = this.template.content.cloneNode(true);\r\n        this.bindings.forEach(b => b.applyBinding(content, this.data));\r\n        return Array.prototype.slice.call(content.childNodes);\r\n    }\r\n    updateElement(host) {\r\n        this.createContentElements().forEach(e => {\r\n            host.appendChild(e);\r\n            this.notifyMounted(e);\r\n        });\r\n    }\r\n    notifyMounted(e) {\r\n        e.childNodes.forEach(this.notifyMounted.bind(this));\r\n        e.dispatchEvent(new CustomEvent(\"mount\", {\r\n            bubbles: false,\r\n        }));\r\n    }\r\n    determineBindings(node) {\r\n        if (node instanceof Comment) {\r\n            const pattern = /^\\{\\{wecco-html-([0-9]+)\\}\\}$/g;\r\n            while (true) {\r\n                const match = pattern.exec(node.textContent || \"\");\r\n                if (!match) {\r\n                    break;\r\n                }\r\n                let id;\r\n                if (!node.parentElement) {\r\n                    id = null;\r\n                }\r\n                else if (node.parentElement.hasAttribute(WeccoHtmlIdDataAttributeName)) {\r\n                    id = node.parentElement.getAttribute(WeccoHtmlIdDataAttributeName);\r\n                }\r\n                else {\r\n                    id = HtmlTemplate.generateId();\r\n                    node.parentElement.setAttribute(WeccoHtmlIdDataAttributeName, id);\r\n                }\r\n                this.bindings.push(new CommentNodeBinding(id, parseInt(match[1])));\r\n            }\r\n        }\r\n        if (node instanceof Element) {\r\n            node.getAttributeNames().forEach(attr => {\r\n                const value = node.getAttribute(attr);\r\n                const pattern = /\\{\\{wecco-html-([0-9]+)\\}\\}/g;\r\n                while (true) {\r\n                    const match = pattern.exec(value);\r\n                    if (!match) {\r\n                        break;\r\n                    }\r\n                    let id;\r\n                    if (node.hasAttribute(WeccoHtmlIdDataAttributeName)) {\r\n                        id = node.getAttribute(WeccoHtmlIdDataAttributeName);\r\n                    }\r\n                    else {\r\n                        id = HtmlTemplate.generateId();\r\n                        node.setAttribute(WeccoHtmlIdDataAttributeName, id);\r\n                    }\r\n                    this.bindings.push(new AttributeBinding(attr, id, parseInt(match[1])));\r\n                }\r\n            });\r\n        }\r\n        node.childNodes.forEach((c, i) => {\r\n            this.determineBindings(c);\r\n        });\r\n    }\r\n    static generateHtml(strings) {\r\n        let html = \"\";\r\n        strings.forEach((s, i) => {\r\n            html += s;\r\n            if (i < strings.length - 1) {\r\n                if (PlaceholderAttributeRegex.test(html) || PlaceholderSingleQuotedAttributeRegex.test(html) || PlaceholderDoubleQuotedAttributeRegex.test(html)) {\r\n                    // Placeholder is used as an attribute value. Insert placeholder\r\n                    html += `{{wecco-html-${i}}}`;\r\n                }\r\n                else {\r\n                    // Placeholder is used as text content. Insert a comment node\r\n                    html += `<!--{{wecco-html-${i}}}-->`;\r\n                }\r\n            }\r\n        });\r\n        return html;\r\n    }\r\n    static generateId() {\r\n        const firstPart = (Math.random() * 46656) | 0;\r\n        const secondPart = (Math.random() * 46656) | 0;\r\n        return (\"000\" + firstPart.toString(36)).slice(-3) + (\"000\" + secondPart.toString(36)).slice(-3);\r\n    }\r\n}\n\n/*\r\n * This file is part of wecco.\r\n *\r\n * Copyright (c) 2019 - 2020 The wecco authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nfunction app(modelInitialier, updater, view, mountPoint) {\r\n    return new AppContextImpl(modelInitialier(), updater, view, resolve(mountPoint));\r\n}\r\nclass AppContextImpl {\r\n    constructor(model, updater, view, mointPoint) {\r\n        this.model = model;\r\n        this.updater = updater;\r\n        this.view = view;\r\n        this.mointPoint = mointPoint;\r\n        this.renderUpdateTimeout = null;\r\n        updateElement(this.mointPoint, this.view(this.model, this));\r\n    }\r\n    emit(message) {\r\n        this.model = this.updater(this.model, message, this);\r\n        if (this.renderUpdateTimeout === null) {\r\n            this.renderUpdateTimeout = window.setTimeout(() => {\r\n                this.renderUpdateTimeout = null;\r\n                removeAllChildren(this.mointPoint);\r\n                updateElement(this.mointPoint, this.view(this.model, this));\r\n            }, 5);\r\n        }\r\n    }\r\n}\n\n\n//# sourceMappingURL=wecco-core.es5.js.map\n\n\n//# sourceURL=webpack://diceroller/./node_modules/@wecco/core/dist/wecco-core.es5.js?");

/***/ }),

/***/ "./src/browser/index.ts":
/*!******************************!*\
  !*** ./src/browser/index.ts ***!
  \******************************/
/***/ (function(__unused_webpack_module, exports) {

eval("\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.notify = exports.copyTextToClipboard = exports.isClipboardSupported = exports.shareText = exports.isSharingSupported = void 0;\r\nfunction isSharingSupported() {\r\n    return typeof (navigator.share) === \"function\";\r\n}\r\nexports.isSharingSupported = isSharingSupported;\r\nfunction shareText(text) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n        if (!isSharingSupported) {\r\n            return Promise.reject(\"sharing is not supported\");\r\n        }\r\n        return navigator.share({\r\n            text: text,\r\n        });\r\n    });\r\n}\r\nexports.shareText = shareText;\r\nfunction isClipboardSupported() {\r\n    return typeof (navigator.clipboard) !== \"undefined\";\r\n}\r\nexports.isClipboardSupported = isClipboardSupported;\r\nfunction copyTextToClipboard(text) {\r\n    if (!isSharingSupported) {\r\n        return Promise.reject(\"clipboard not supported\");\r\n    }\r\n    return navigator.clipboard.writeText(text);\r\n}\r\nexports.copyTextToClipboard = copyTextToClipboard;\r\nfunction notify(message) {\r\n    M.toast({ html: message });\r\n}\r\nexports.notify = notify;\r\n\n\n//# sourceURL=webpack://diceroller/./src/browser/index.ts?");

/***/ }),

/***/ "./src/control/index.ts":
/*!******************************!*\
  !*** ./src/control/index.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.update = exports.Share = exports.Copy = exports.EmptyPool = exports.Roll = exports.RemoveDie = exports.AddDie = void 0;\r\nconst browser_1 = __webpack_require__(/*! src/browser */ \"./src/browser/index.ts\");\r\nconst utils_1 = __webpack_require__(/*! src/utils */ \"./src/utils/index.ts\");\r\nconst models_1 = __webpack_require__(/*! ../models */ \"./src/models/index.ts\");\r\nclass AddDie {\r\n    constructor(kind) {\r\n        this.kind = kind;\r\n        this.command = \"add-die\";\r\n    }\r\n}\r\nexports.AddDie = AddDie;\r\nclass RemoveDie {\r\n    constructor(die) {\r\n        this.die = die;\r\n        this.command = \"remove-die\";\r\n    }\r\n}\r\nexports.RemoveDie = RemoveDie;\r\nclass Roll {\r\n    constructor() {\r\n        this.command = \"roll\";\r\n    }\r\n}\r\nexports.Roll = Roll;\r\nclass EmptyPool {\r\n    constructor() {\r\n        this.command = \"empty-pool\";\r\n    }\r\n}\r\nexports.EmptyPool = EmptyPool;\r\nclass Copy {\r\n    constructor() {\r\n        this.command = \"copy\";\r\n    }\r\n}\r\nexports.Copy = Copy;\r\nclass Share {\r\n    constructor() {\r\n        this.command = \"share\";\r\n    }\r\n}\r\nexports.Share = Share;\r\nfunction update(model, msg) {\r\n    let p;\r\n    switch (msg.command) {\r\n        case \"add-die\":\r\n            p = model.pool.addDie(selectDie(msg.kind));\r\n            history.replaceState(null, \"\", `/#${utils_1.poolToUrlHash(p)}`);\r\n            return new models_1.Model(p);\r\n        case \"remove-die\":\r\n            p = model.pool.removeDie(msg.die);\r\n            history.replaceState(null, \"\", `/#${utils_1.poolToUrlHash(p)}`);\r\n            return new models_1.Model(p);\r\n        case \"roll\":\r\n            return new models_1.Model(model.pool, model.pool.roll());\r\n        case \"empty-pool\":\r\n            history.replaceState(null, \"\", `/#`);\r\n            return new models_1.Model(models_1.Pool.empty());\r\n        case \"copy\":\r\n            if (typeof model.poolResult === \"undefined\") {\r\n                console.error(\"inconsistency detected: can't copy while poolResult is undefined\");\r\n                return model;\r\n            }\r\n            if (browser_1.isClipboardSupported()) {\r\n                browser_1.copyTextToClipboard(model.poolResult.normalize().format());\r\n                browser_1.notify(\"Copied to clipboard\");\r\n            }\r\n            return model;\r\n        case \"share\":\r\n            if (typeof model.poolResult === \"undefined\") {\r\n                console.error(\"inconsistency detected: can't share while poolResult is undefined\");\r\n                return model;\r\n            }\r\n            if (browser_1.isSharingSupported()) {\r\n                browser_1.shareText(model.poolResult.normalize().format());\r\n            }\r\n            return model;\r\n    }\r\n}\r\nexports.update = update;\r\nfunction selectDie(k) {\r\n    switch (k) {\r\n        case models_1.DieKind.Ability:\r\n            return models_1.Die.Ability;\r\n        case models_1.DieKind.Proficiency:\r\n            return models_1.Die.Proficiency;\r\n        case models_1.DieKind.Difficulty:\r\n            return models_1.Die.Difficulty;\r\n        case models_1.DieKind.Challange:\r\n            return models_1.Die.Challange;\r\n        case models_1.DieKind.Boost:\r\n            return models_1.Die.Boost;\r\n        case models_1.DieKind.Setback:\r\n            return models_1.Die.Setback;\r\n        case models_1.DieKind.Force:\r\n            return models_1.Die.Force;\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://diceroller/./src/control/index.ts?");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nconst wecco = __webpack_require__(/*! @wecco/core */ \"./node_modules/@wecco/core/dist/wecco-core.es5.js\");\r\nconst control_1 = __webpack_require__(/*! ./control */ \"./src/control/index.ts\");\r\nconst models_1 = __webpack_require__(/*! ./models */ \"./src/models/index.ts\");\r\nconst utils_1 = __webpack_require__(/*! ./utils */ \"./src/utils/index.ts\");\r\nconst views_1 = __webpack_require__(/*! ./views */ \"./src/views/index.ts\");\r\ndocument.addEventListener(\"DOMContentLoaded\", () => {\r\n    const context = wecco.app(() => new models_1.Model(models_1.Pool.empty()), control_1.update, views_1.root, \"#app\");\r\n    if (document.location.hash.length > 0) {\r\n        document.location.hash.substr(1).split(\"\").forEach(c => {\r\n            try {\r\n                context.emit(new control_1.AddDie(utils_1.charToDieKind(c)));\r\n            }\r\n            catch (e) {\r\n                // Nothing to do here; dispatching the AddDie message forces a rewrite of the url eliminating any misplaced chars.\r\n            }\r\n        });\r\n    }\r\n});\r\n\n\n//# sourceURL=webpack://diceroller/./src/index.ts?");

/***/ }),

/***/ "./src/models/index.ts":
/*!*****************************!*\
  !*** ./src/models/index.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.Model = exports.PoolResult = exports.Pool = exports.DieResult = exports.Die = exports.DieKind = exports.Symbol = void 0;\r\nvar Symbol;\r\n(function (Symbol) {\r\n    Symbol[\"Success\"] = \"success\";\r\n    Symbol[\"Advantage\"] = \"advantage\";\r\n    Symbol[\"Failure\"] = \"failure\";\r\n    Symbol[\"Threat\"] = \"threat\";\r\n    Symbol[\"Triumph\"] = \"triumph\";\r\n    Symbol[\"Despair\"] = \"despair\";\r\n    Symbol[\"LightSide\"] = \"lightside\";\r\n    Symbol[\"DarkSide\"] = \"darkside\";\r\n})(Symbol = exports.Symbol || (exports.Symbol = {}));\r\nvar DieKind;\r\n(function (DieKind) {\r\n    DieKind[\"Ability\"] = \"ability\";\r\n    DieKind[\"Proficiency\"] = \"proficiency\";\r\n    DieKind[\"Difficulty\"] = \"difficulty\";\r\n    DieKind[\"Challange\"] = \"challange\";\r\n    DieKind[\"Boost\"] = \"boost\";\r\n    DieKind[\"Setback\"] = \"setback\";\r\n    DieKind[\"Force\"] = \"force\";\r\n})(DieKind = exports.DieKind || (exports.DieKind = {}));\r\nclass Die {\r\n    constructor(kind, sides) {\r\n        this.kind = kind;\r\n        this.sides = sides;\r\n    }\r\n    static get Ability() {\r\n        return new Die(DieKind.Ability, [\r\n            null,\r\n            Symbol.Success,\r\n            [Symbol.Success, Symbol.Success],\r\n            Symbol.Advantage,\r\n            [Symbol.Advantage, Symbol.Advantage],\r\n            Symbol.Success,\r\n            [Symbol.Advantage, Symbol.Success],\r\n            Symbol.Advantage,\r\n        ]);\r\n    }\r\n    static get Proficiency() {\r\n        return new Die(DieKind.Proficiency, [\r\n            null,\r\n            Symbol.Success,\r\n            Symbol.Success,\r\n            Symbol.Triumph,\r\n            [Symbol.Success, Symbol.Success],\r\n            [Symbol.Success, Symbol.Success],\r\n            [Symbol.Advantage, Symbol.Advantage],\r\n            [Symbol.Advantage, Symbol.Advantage],\r\n            Symbol.Advantage,\r\n            [Symbol.Success, Symbol.Advantage],\r\n            [Symbol.Success, Symbol.Advantage],\r\n            [Symbol.Success, Symbol.Advantage],\r\n        ]);\r\n    }\r\n    static get Difficulty() {\r\n        return new Die(DieKind.Difficulty, [\r\n            null,\r\n            [Symbol.Failure, Symbol.Failure],\r\n            Symbol.Threat,\r\n            [Symbol.Failure, Symbol.Threat],\r\n            [Symbol.Threat, Symbol.Threat],\r\n            Symbol.Threat,\r\n            Symbol.Failure,\r\n            Symbol.Threat,\r\n        ]);\r\n    }\r\n    static get Challange() {\r\n        return new Die(DieKind.Challange, [\r\n            null,\r\n            Symbol.Failure,\r\n            Symbol.Failure,\r\n            Symbol.Threat,\r\n            Symbol.Threat,\r\n            Symbol.Despair,\r\n            [Symbol.Threat, Symbol.Threat],\r\n            [Symbol.Threat, Symbol.Threat],\r\n            [Symbol.Failure, Symbol.Failure],\r\n            [Symbol.Failure, Symbol.Failure],\r\n            [Symbol.Failure, Symbol.Threat],\r\n            [Symbol.Failure, Symbol.Threat],\r\n        ]);\r\n    }\r\n    static get Boost() {\r\n        return new Die(DieKind.Boost, [\r\n            null,\r\n            null,\r\n            Symbol.Success,\r\n            Symbol.Advantage,\r\n            [Symbol.Success, Symbol.Advantage],\r\n            [Symbol.Advantage, Symbol.Advantage],\r\n        ]);\r\n    }\r\n    static get Setback() {\r\n        return new Die(DieKind.Setback, [\r\n            null,\r\n            null,\r\n            Symbol.Failure,\r\n            Symbol.Failure,\r\n            Symbol.Threat,\r\n            Symbol.Threat,\r\n        ]);\r\n    }\r\n    static get Force() {\r\n        return new Die(DieKind.Force, [\r\n            Symbol.LightSide,\r\n            Symbol.LightSide,\r\n            Symbol.DarkSide,\r\n            Symbol.DarkSide,\r\n            Symbol.DarkSide,\r\n            Symbol.DarkSide,\r\n            Symbol.DarkSide,\r\n            Symbol.DarkSide,\r\n            [Symbol.LightSide, Symbol.LightSide],\r\n            [Symbol.LightSide, Symbol.LightSide],\r\n            [Symbol.LightSide, Symbol.LightSide],\r\n            [Symbol.DarkSide, Symbol.DarkSide],\r\n        ]);\r\n    }\r\n    roll() {\r\n        const side = this.sides[Math.floor(Math.random() * Math.floor(this.sides.length))];\r\n        if (side === null) {\r\n            return DieResult.blank();\r\n        }\r\n        if (Array.isArray(side)) {\r\n            return new DieResult(side);\r\n        }\r\n        return new DieResult([side]);\r\n    }\r\n}\r\nexports.Die = Die;\r\nclass DieResult {\r\n    constructor(symbols) {\r\n        this.symbols = symbols;\r\n    }\r\n    static blank() {\r\n        return new DieResult([]);\r\n    }\r\n}\r\nexports.DieResult = DieResult;\r\nclass Pool {\r\n    constructor(dice) {\r\n        this.dice = dice;\r\n    }\r\n    static empty() {\r\n        return new Pool([]);\r\n    }\r\n    get empty() {\r\n        return this.dice.length === 0;\r\n    }\r\n    addDie(die) {\r\n        const dice = [...(this.dice)];\r\n        dice.push(die);\r\n        // TODO: Sort pool\r\n        return new Pool(dice);\r\n    }\r\n    removeDie(die) {\r\n        const dice = [...(this.dice)];\r\n        dice.splice(dice.indexOf(die), 1);\r\n        return new Pool(dice);\r\n    }\r\n    roll() {\r\n        return new PoolResult(this.dice.map(d => d.roll()));\r\n    }\r\n}\r\nexports.Pool = Pool;\r\nclass NormalizedPoolResultImpl {\r\n    constructor(data) {\r\n        this.data = data;\r\n    }\r\n    get success() {\r\n        var _a;\r\n        return (_a = this.data[Symbol.Success]) !== null && _a !== void 0 ? _a : 0;\r\n    }\r\n    get advantage() {\r\n        var _a;\r\n        return (_a = this.data[Symbol.Advantage]) !== null && _a !== void 0 ? _a : 0;\r\n    }\r\n    get triumph() {\r\n        var _a;\r\n        return (_a = this.data[Symbol.Triumph]) !== null && _a !== void 0 ? _a : 0;\r\n    }\r\n    get failure() {\r\n        var _a;\r\n        return (_a = this.data[Symbol.Failure]) !== null && _a !== void 0 ? _a : 0;\r\n    }\r\n    get threat() {\r\n        var _a;\r\n        return (_a = this.data[Symbol.Threat]) !== null && _a !== void 0 ? _a : 0;\r\n    }\r\n    get despair() {\r\n        var _a;\r\n        return (_a = this.data[Symbol.Despair]) !== null && _a !== void 0 ? _a : 0;\r\n    }\r\n    get lightside() {\r\n        var _a;\r\n        return (_a = this.data[Symbol.LightSide]) !== null && _a !== void 0 ? _a : 0;\r\n    }\r\n    get darkside() {\r\n        var _a;\r\n        return (_a = this.data[Symbol.DarkSide]) !== null && _a !== void 0 ? _a : 0;\r\n    }\r\n    format() {\r\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r;\r\n        let s = \"\";\r\n        if (((_a = this.data[Symbol.Success]) !== null && _a !== void 0 ? _a : 0) > 0) {\r\n            s += `${this.data[Symbol.Success]} Success${((_b = this.data[Symbol.Success]) !== null && _b !== void 0 ? _b : 0) > 1 ? \"es\" : \"\"}`;\r\n        }\r\n        if (((_c = this.data[Symbol.Advantage]) !== null && _c !== void 0 ? _c : 0) > 0) {\r\n            if (s.length > 0) {\r\n                s += \", \";\r\n            }\r\n            s += `${this.data[Symbol.Advantage]} Advantage${((_d = this.data[Symbol.Advantage]) !== null && _d !== void 0 ? _d : 0) > 1 ? \"s\" : \"\"}`;\r\n        }\r\n        if (((_e = this.data[Symbol.Triumph]) !== null && _e !== void 0 ? _e : 0) > 0) {\r\n            if (s.length > 0) {\r\n                s += \", \";\r\n            }\r\n            s += `${this.data[Symbol.Triumph]} Triumph${((_f = this.data[Symbol.Triumph]) !== null && _f !== void 0 ? _f : 0) > 1 ? \"s\" : \"\"}`;\r\n        }\r\n        if (((_g = this.data[Symbol.Failure]) !== null && _g !== void 0 ? _g : 0) > 0) {\r\n            if (s.length > 0) {\r\n                s += \", \";\r\n            }\r\n            s += `${this.data[Symbol.Failure]} Failure${((_h = this.data[Symbol.Failure]) !== null && _h !== void 0 ? _h : 0) > 1 ? \"s\" : \"\"}`;\r\n        }\r\n        if (((_j = this.data[Symbol.Threat]) !== null && _j !== void 0 ? _j : 0) > 0) {\r\n            if (s.length > 0) {\r\n                s += \", \";\r\n            }\r\n            s += `${this.data[Symbol.Threat]} Threat${((_k = this.data[Symbol.Threat]) !== null && _k !== void 0 ? _k : 0) > 1 ? \"s\" : \"\"}`;\r\n        }\r\n        if (((_l = this.data[Symbol.Despair]) !== null && _l !== void 0 ? _l : 0) > 0) {\r\n            if (s.length > 0) {\r\n                s += \", \";\r\n            }\r\n            s += `${this.data[Symbol.Despair]} Despair${((_m = this.data[Symbol.Despair]) !== null && _m !== void 0 ? _m : 0) > 1 ? \"s\" : \"\"}`;\r\n        }\r\n        if (((_o = this.data[Symbol.LightSide]) !== null && _o !== void 0 ? _o : 0) > 0) {\r\n            if (s.length > 0) {\r\n                s += \", \";\r\n            }\r\n            s += `${this.data[Symbol.LightSide]} Light Side${((_p = this.data[Symbol.LightSide]) !== null && _p !== void 0 ? _p : 0) > 1 ? \"s\" : \"\"}`;\r\n        }\r\n        if (((_q = this.data[Symbol.DarkSide]) !== null && _q !== void 0 ? _q : 0) > 0) {\r\n            if (s.length > 0) {\r\n                s += \", \";\r\n            }\r\n            s += `${this.data[Symbol.DarkSide]} Dark Side${((_r = this.data[Symbol.DarkSide]) !== null && _r !== void 0 ? _r : 0) > 1 ? \"s\" : \"\"}`;\r\n        }\r\n        return s;\r\n    }\r\n}\r\nclass PoolResult {\r\n    constructor(dieResults) {\r\n        this.dieResults = dieResults;\r\n    }\r\n    normalize() {\r\n        const aggregates = this.aggregate();\r\n        const result = {};\r\n        const applyDelta = (left, right) => {\r\n            if (aggregates[left] > aggregates[right]) {\r\n                result[left] = aggregates[left] - aggregates[right];\r\n            }\r\n            else if (aggregates[left] < aggregates[right]) {\r\n                result[right] = aggregates[right] - aggregates[left];\r\n            }\r\n        };\r\n        const copyPositive = (s) => {\r\n            if (aggregates[s] > 0) {\r\n                result[s] = aggregates[s];\r\n            }\r\n        };\r\n        applyDelta(Symbol.Success, Symbol.Failure);\r\n        applyDelta(Symbol.Advantage, Symbol.Threat);\r\n        copyPositive(Symbol.Triumph);\r\n        copyPositive(Symbol.Despair);\r\n        copyPositive(Symbol.LightSide);\r\n        copyPositive(Symbol.DarkSide);\r\n        return new NormalizedPoolResultImpl(result);\r\n    }\r\n    aggregate() {\r\n        const result = {\r\n            success: 0,\r\n            advantage: 0,\r\n            triumph: 0,\r\n            failure: 0,\r\n            threat: 0,\r\n            despair: 0,\r\n            lightside: 0,\r\n            darkside: 0,\r\n        };\r\n        this.dieResults\r\n            .flatMap(r => r.symbols)\r\n            .map(s => {\r\n            result[s]++;\r\n            if (s === Symbol.Triumph) {\r\n                result[Symbol.Success]++;\r\n            }\r\n            else if (s === Symbol.Despair) {\r\n                result[Symbol.Failure]++;\r\n            }\r\n        });\r\n        return result;\r\n    }\r\n}\r\nexports.PoolResult = PoolResult;\r\nclass Model {\r\n    constructor(pool, poolResult) {\r\n        this.pool = pool;\r\n        this.poolResult = poolResult;\r\n    }\r\n}\r\nexports.Model = Model;\r\n\n\n//# sourceURL=webpack://diceroller/./src/models/index.ts?");

/***/ }),

/***/ "./src/utils/index.ts":
/*!****************************!*\
  !*** ./src/utils/index.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.charToDieKind = exports.dieKindToChar = exports.poolToUrlHash = void 0;\r\nconst models_1 = __webpack_require__(/*! src/models */ \"./src/models/index.ts\");\r\nfunction poolToUrlHash(p) {\r\n    return p.dice.map(d => dieKindToChar(d.kind)).join(\"\");\r\n}\r\nexports.poolToUrlHash = poolToUrlHash;\r\nfunction dieKindToChar(k) {\r\n    switch (k) {\r\n        case models_1.DieKind.Ability: return \"A\";\r\n        case models_1.DieKind.Proficiency: return \"P\";\r\n        case models_1.DieKind.Difficulty: return \"D\";\r\n        case models_1.DieKind.Challange: return \"C\";\r\n        case models_1.DieKind.Boost: return \"B\";\r\n        case models_1.DieKind.Setback: return \"S\";\r\n        case models_1.DieKind.Force: return \"F\";\r\n    }\r\n}\r\nexports.dieKindToChar = dieKindToChar;\r\nfunction charToDieKind(c) {\r\n    switch (c) {\r\n        case \"A\": return models_1.DieKind.Ability;\r\n        case \"P\": return models_1.DieKind.Proficiency;\r\n        case \"D\": return models_1.DieKind.Difficulty;\r\n        case \"C\": return models_1.DieKind.Challange;\r\n        case \"B\": return models_1.DieKind.Boost;\r\n        case \"S\": return models_1.DieKind.Setback;\r\n        case \"F\": return models_1.DieKind.Force;\r\n        default:\r\n            throw `invalid die kind character: ${c}`;\r\n    }\r\n}\r\nexports.charToDieKind = charToDieKind;\r\n\n\n//# sourceURL=webpack://diceroller/./src/utils/index.ts?");

/***/ }),

/***/ "./src/views/index.ts":
/*!****************************!*\
  !*** ./src/views/index.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.root = void 0;\r\nconst wecco = __webpack_require__(/*! @wecco/core */ \"./node_modules/@wecco/core/dist/wecco-core.es5.js\");\r\nconst control_1 = __webpack_require__(/*! ../control */ \"./src/control/index.ts\");\r\nconst models_1 = __webpack_require__(/*! ../models */ \"./src/models/index.ts\");\r\nconst package_json_1 = __webpack_require__(/*! ../../package.json */ \"./package.json\");\r\nconst browser_1 = __webpack_require__(/*! src/browser */ \"./src/browser/index.ts\");\r\nfunction root(model, context) {\r\n    return appShell(wecco.html `\r\n    <div class=\"row\">\r\n        <div class=\"col s12 m12 l6\">\r\n            <h2>Pool</h2>\r\n            <p class=\"center-align\">\r\n                ${addDie(models_1.DieKind.Ability, context)}\r\n                ${addDie(models_1.DieKind.Proficiency, context)}\r\n                ${addDie(models_1.DieKind.Difficulty, context)}\r\n                ${addDie(models_1.DieKind.Challange, context)}\r\n                ${addDie(models_1.DieKind.Boost, context)}\r\n                ${addDie(models_1.DieKind.Setback, context)}\r\n                ${addDie(models_1.DieKind.Force, context)}\r\n            </p>\r\n            <p>Tap a small die above to add it to the pool. Tap a die from the pool below to remove it.</p>\r\n            ${pool(model.pool, context)}\r\n        </div>\r\n        ${model.poolResult ? result(model.poolResult.normalize(), context) : \"\"}\r\n    </div>\r\n    `);\r\n}\r\nexports.root = root;\r\nfunction pool(pool, context) {\r\n    if (pool.empty) {\r\n        return wecco.html `<p class=\"center-align flow-text\"><em>Empty pool</em></p>`;\r\n    }\r\n    return wecco.html `\r\n        <p class=\"center-align\">\r\n            ${pool.dice.map(d => removeDie(d, context))}\r\n        </p>\r\n        <p class=\"right-align\">\r\n            <a class=\"btn waves-effect waves-light m-r2 blue-grey lighten-1\" @click=${() => context.emit(new control_1.EmptyPool())}>Empty Pool</a>\r\n            <a class=\"btn waves-effect waves-light m-r2 light-blue darken-4\" @click=${() => context.emit(new control_1.Roll())}>Roll Dice</a>\r\n        </p>\r\n    `;\r\n}\r\nfunction result(result, context) {\r\n    return wecco.html `\r\n    <div class=\"col s12 m12 l6\">\r\n        <h2>Result</h2>\r\n        <div class=\"center-align\">\r\n            ${resultIcons(result)}\r\n            ${resultText(result)}\r\n        </div>\r\n        <div class=\"right-align\">\r\n            ${browser_1.isClipboardSupported() ? wecco.html `<a class=\"\"btn waves-effect waves-light m-r2 blue-grey lighten-1\" @click=${() => context.emit(new control_1.Copy())}><i class=\"material-icons\">content_copy</i></a>` : \"\"}\r\n            ${browser_1.isSharingSupported() ? wecco.html `<a class=\"\"btn waves-effect waves-light m-r2 blue-grey lighten-1\" @click=${() => context.emit(new control_1.Share())}><i class=\"material-icons\">share</i></a>` : \"\"}\r\n        </div>\r\n    </div>\r\n    `;\r\n}\r\nfunction resultText(result) {\r\n    return wecco.html `<p class=\"flow-text\">${result.format()}</p>`;\r\n}\r\nfunction resultIcons(result) {\r\n    const symbols = [];\r\n    const contributeIcons = (s) => {\r\n        var _a;\r\n        for (let i = 0; i < ((_a = result[s]) !== null && _a !== void 0 ? _a : 0); i++) {\r\n            symbols.push(symbolIcon(s));\r\n        }\r\n    };\r\n    contributeIcons(models_1.Symbol.Success);\r\n    contributeIcons(models_1.Symbol.Advantage);\r\n    contributeIcons(models_1.Symbol.Triumph);\r\n    contributeIcons(models_1.Symbol.Failure);\r\n    contributeIcons(models_1.Symbol.Threat);\r\n    contributeIcons(models_1.Symbol.Despair);\r\n    contributeIcons(models_1.Symbol.LightSide);\r\n    contributeIcons(models_1.Symbol.DarkSide);\r\n    return wecco.html `${symbols}`;\r\n}\r\nfunction symbolIcon(s) {\r\n    return wecco.html `<svg class=\"roll-icon\" xmlns=\"http://www.w3.org/2000/svg\"><use href=\"#icon-${s}\" xmlns=\"http://www.w3.org/2000/svg\"></use></svg>`;\r\n}\r\nfunction removeDie(die, context) {\r\n    return dieButton(die.kind, \"\", new control_1.RemoveDie(die), context);\r\n}\r\nfunction addDie(die, context) {\r\n    return dieButton(die, \"btn-small\", new control_1.AddDie(die), context);\r\n}\r\nfunction dieButton(die, additionalStyleClasses, msg, context) {\r\n    const [styleClasses, label] = determineButtonStyle(die);\r\n    return wecco.html `<button class=\"btn waves-effect waves-light m-r2 ${styleClasses} ${additionalStyleClasses}\" @click=${() => context.emit(msg)}>${label}</button>`;\r\n}\r\nfunction determineButtonStyle(die) {\r\n    switch (die) {\r\n        case models_1.DieKind.Ability:\r\n            return [\"green\", \"A\"];\r\n        case models_1.DieKind.Proficiency:\r\n            return [\"yellow black-text\", \"P\"];\r\n        case models_1.DieKind.Difficulty:\r\n            return [\"purple darken-3\", \"D\"];\r\n        case models_1.DieKind.Challange:\r\n            return [\"red\", \"C\"];\r\n        case models_1.DieKind.Boost:\r\n            return [\"blue lighten-2 black-text\", \"B\"];\r\n        case models_1.DieKind.Setback:\r\n            return [\"black\", \"S\"];\r\n        case models_1.DieKind.Force:\r\n            return [\"white black-text\", \"F\"];\r\n    }\r\n}\r\nfunction appShell(main) {\r\n    return wecco.html `\r\n    <header>\r\n        <nav>\r\n            <div class=\"nav-wrapper blue-grey darken-4\">\r\n                <a class=\"brand-logo left\" href=\"/\">Dice Roller</a>\r\n            </div>\r\n        </nav>\r\n    </header>\r\n    <main>\r\n        <div class=\"container\">${main}</div>        \r\n    </main>\r\n    <footer class=\"page-footer blue-grey darken-2\">\r\n        <div class=\"container\">\r\n            <div class=\"row\">\r\n                <div class=\"col s12 m6\">\r\n                    <p>DiceRoller v${package_json_1.version}</p>\r\n                    <p>Copyright (c) 2020 Alexander Metzner.</p>\r\n                </div>\r\n                <div class=\"col s12 m6 right\">\r\n                    <a href=\"https://bitbucket.org/halimath/diceroller/src/master/\">bitbucket.org/halimath/diceroller</a>\r\n                </div>\r\n            </div>\r\n        </div>\r\n    </footer>\r\n    `;\r\n}\r\n\n\n//# sourceURL=webpack://diceroller/./src/views/index.ts?");

/***/ }),

/***/ "./package.json":
/*!**********************!*\
  !*** ./package.json ***!
  \**********************/
/***/ ((module) => {

eval("module.exports = JSON.parse(\"{\\\"name\\\":\\\"diceroller\\\",\\\"version\\\":\\\"0.5.0\\\",\\\"author\\\":{\\\"name\\\":\\\"Alexander Metzner\\\",\\\"email\\\":\\\"alexander.metzner@gmail.com\\\"},\\\"dependencies\\\":{\\\"@wecco/core\\\":\\\"https://bitbucket.org/wecco/core/downloads/wecco-core-0.13.0.tgz\\\"},\\\"devDependencies\\\":{\\\"typescript\\\":\\\"^4.1.2\\\",\\\"webpack\\\":\\\"^5.6.0\\\",\\\"webpack-dev-server\\\":\\\"^3.11.0\\\",\\\"webpack-cli\\\":\\\"^4.2.0\\\",\\\"ts-loader\\\":\\\"^8.0.11\\\",\\\"tsconfig-paths-webpack-plugin\\\":\\\"^3.3.0\\\",\\\"mocha\\\":\\\"^8.2.1\\\",\\\"@types/mocha\\\":\\\"^8.2.0\\\",\\\"chai\\\":\\\"^4.2.0\\\",\\\"@types/chai\\\":\\\"^4.2.14\\\",\\\"ts-node\\\":\\\"^9.1.1\\\"},\\\"scripts\\\":{\\\"build\\\":\\\"webpack\\\",\\\"start\\\":\\\"webpack serve\\\",\\\"test\\\":\\\"mocha --require ts-node/register test/**/*.test.ts\\\"}}\");\n\n//# sourceURL=webpack://diceroller/./package.json?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		if(__webpack_module_cache__[moduleId]) {
/******/ 			return __webpack_module_cache__[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop)
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	// startup
/******/ 	// Load entry module
/******/ 	__webpack_require__("./src/index.ts");
/******/ 	// This entry module used 'exports' so it can't be inlined
/******/ })()
;